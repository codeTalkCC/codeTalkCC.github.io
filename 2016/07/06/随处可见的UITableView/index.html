<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 随处可见的UITableView · codeTalk</title><meta name="description" content="随处可见的UITableView - zjcai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codeTalkCC" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/selfAbout.html" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">随处可见的UITableView</h1><div class="post-info">2016年7月6日</div><div class="post-content"><p>iOS中处处可以见到UITableView的使用。<br>系统里UITableView的使用：<img src="https://raw.githubusercontent.com/codeTalkCC/ArcitlePhotos/master/%E9%9A%8F%E5%A4%84%E5%8F%AF%E8%A7%81%E7%9A%84UITableView/IMG_1913.jpg" alt="设置界面"><br>微信里UITableView的使用：<img src="https://raw.githubusercontent.com/codeTalkCC/ArcitlePhotos/master/%E9%9A%8F%E5%A4%84%E5%8F%AF%E8%A7%81%E7%9A%84UITableView/THVE5337.jpg" alt="微信"><br><img src="https://raw.githubusercontent.com/codeTalkCC/ArcitlePhotos/master/%E9%9A%8F%E5%A4%84%E5%8F%AF%E8%A7%81%E7%9A%84UITableView/ITSN0039.jpg" alt="微信朋友圈"></p>
<p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableView_Class/" target="_blank" rel="external">UITableView官方文档</a><br>UITableView的用途以及如何使用，使用的注意点都可以通过阅读官方文档解读出来<br>你可以过一遍官方文档来了解下UITableView<br>我总结如下</p>
<ul>
<li>1.一个UITableView的实例（下文都用_tableView来表示）用来展示列表信息</li>
<li><ol>
<li>_tableView继承自UIScorllerView,由许多的UITableViewCell的实例对象组成</li>
</ol>
</li>
<li>3.cell有很多不同类型,不同cell类型的结构:</li>
<li><ol>
<li>_tableView可以有0或多个sections，每个sections有它自己的rows，section header和section footer</li>
</ol>
</li>
<li>5 _tableView有2个类型： UITableViewStylePlain， UITableViewStyleGrouped</li>
<li>6 _tableView必须有UITableViewDataSource的代理来展示数据</li>
<li>7 _tableView有重用机制</li>
</ul>
<p>本文我会讲解UITableView的基本使用，进阶的一些用法，tableView重用机制的解释，<br>接下来的目录</p>
<ul>
<li>一：UITableView的基本使用 - 展示 - 增加 - 删除 - 移动</li>
<li>二：自定义cell样式</li>
<li>三：带搜索框的UITableView</li>
<li>四：UItableView的内存管理和重用机制</li>
<li>五：深度定制UItableView</li>
</ul>
<h4 id="一：UITableView-的基本使用"><a href="#一：UITableView-的基本使用" class="headerlink" title="一：UITableView 的基本使用"></a>一：UITableView 的基本使用</h4><p>你可以使用拖控件的方式或者代码的方式创建一个实例对象，我的是代码创建的 -&gt; 创建或者查询数据 -&gt; 实现UITableViewDataSource的代理方法来正确的展示数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)configTableView&#123;</span><br><span class="line">    if (!_tableView) &#123;</span><br><span class="line">        _tableView = [[UITableView alloc]init];</span><br><span class="line">        _tableView.frame = self.view.frame;</span><br><span class="line">        _tableView.dataSource = self;</span><br><span class="line">        _tableView.delegate = self;</span><br><span class="line">        [self.view addSubview:_tableView];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)querryData&#123;</span><br><span class="line">    _records = [[NSMutableArray alloc]init];</span><br><span class="line">    for (NSInteger i = 0; i &lt; 100; i ++) &#123;</span><br><span class="line">        NSString *iS = [NSString stringWithFormat:@&quot;%ld&quot;,(long)i];</span><br><span class="line">        [_records addObject:iS];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现代理UITableViewDataSource</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - UITableViewDataSource</span><br><span class="line"></span><br><span class="line">- (NSInteger )numberOfSectionsInTableView:(UITableView *)tableView&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;</span><br><span class="line">    return _records.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    static NSString * const kCellIdentifier = @&quot;CellIdentifierBaseUse&quot;;</span><br><span class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:kCellIdentifier];</span><br><span class="line">    if (!cell) &#123;</span><br><span class="line">        cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:kCellIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //config</span><br><span class="line">    if (indexPath.row &lt; _records.count) &#123;</span><br><span class="line">        NSString *string = _records[indexPath.row];</span><br><span class="line">        cell.textLabel.text = string;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样你的信息就展示出来了，如图所示：</p>
<p><img src="https://raw.githubusercontent.com/codeTalkCC/ArcitlePhotos/master/%E9%9A%8F%E5%A4%84%E5%8F%AF%E8%A7%81%E7%9A%84UITableView/IMG_1939.jpg" alt="基本使用效果图"></p>
<p>在iOS中，在tableView里的增加，删除，移动cell，系统也帮我们高度集成了，我们需要知道如何使用：</p>
<p>1.是否可编辑，默认YES<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure></p>
<p>2.当点击响应编辑按钮响应的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure></p>
<p>3.返回编辑按钮的样式，有删除、增加、none，默认删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line">-</span><br></pre></td></tr></table></figure></p>
<p>4.是否可移动 默认YES<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">-</span><br></pre></td></tr></table></figure></p>
<p>5.移动单元格响应的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;</span><br></pre></td></tr></table></figure></p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//响应编辑</span><br><span class="line">- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    </span><br><span class="line">    switch (editingStyle) &#123;</span><br><span class="line">        case UITableViewCellEditingStyleDelete:&#123;</span><br><span class="line">            NSString *object = _records[indexPath.row];</span><br><span class="line">            [_records removeObject:object];</span><br><span class="line">            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];</span><br><span class="line">            NSLog(@&quot;删除&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case UITableViewCellEditingStyleInsert:&#123;</span><br><span class="line">            </span><br><span class="line">            NSString *string = [NSString stringWithFormat:@&quot;%ld&quot;,(long)(arc4random() + 1000)];</span><br><span class="line">            [_records insertObject:string atIndex:indexPath.row + 1];</span><br><span class="line">            NSIndexPath *insertIndexPath = [NSIndexPath indexPathForRow:indexPath.row + 1 inSection:indexPath.section];</span><br><span class="line">            [tableView insertRowsAtIndexPaths:@[insertIndexPath] withRowAnimation:UITableViewRowAnimationBottom];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//响应移动</span><br><span class="line">- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath&#123;</span><br><span class="line">    [_records exchangeObjectAtIndex:sourceIndexPath.row withObjectAtIndex:destinationIndexPath.row];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - UITableViewDelegate</span><br><span class="line"></span><br><span class="line">- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    NSString *object = _records[indexPath.row];</span><br><span class="line">    if([object integerValue] % 2 == 0)&#123;</span><br><span class="line">        </span><br><span class="line">        return UITableViewCellEditingStyleInsert;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return UITableViewCellEditingStyleDelete;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)edit&#123;</span><br><span class="line">    if (_tableView.editing) &#123;</span><br><span class="line">        [_tableView setEditing:NO animated:YES];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [_tableView setEditing:YES animated:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当增加一个cell的时候，显示屏新显示的是新增的cell，删除一个cell的时候，显示屏新显示的是之前在最低端的下一行。所以只会调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure>
<p>一次来显示要新显示的cell</p>
<p>其余的变动，如移动并不会调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure>
<p>来刷新数据，UITableView只是变更下他们的位置而已。</p>
<h4 id="二：自定义-tableView的样式"><a href="#二：自定义-tableView的样式" class="headerlink" title="二：自定义_tableView的样式"></a>二：自定义_tableView的样式</h4><p>自定义cell:<img src="https://raw.githubusercontent.com/codeTalkCC/ArcitlePhotos/master/%E9%9A%8F%E5%A4%84%E5%8F%AF%E8%A7%81%E7%9A%84UITableView/1A629274-6F27-403F-A187-6844E118F43C.png" alt="cell"></p>
<p>为当前的_tableView注册自定义cell，指定重用标识</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> //注册自定义cell</span><br><span class="line">[_tableView registerNib:[UINib nibWithNibName:@&quot;AMissionCell&quot; bundle:nil] forCellReuseIdentifier:@&quot;AMissionCell&quot;];</span><br></pre></td></tr></table></figure>
<p>在返回cell的时候根据数据适配当前cell的UI</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AMissionCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;AMissionCell&quot;];</span><br><span class="line">if (!cell) &#123;</span><br><span class="line">    //这是不可能出现的错误，去看看xib文件的identifier有没有指定</span><br><span class="line">&#125;</span><br><span class="line">if (indexPath.row &lt; _records.count) &#123;</span><br><span class="line">    AMission *object = _records[indexPath.row];</span><br><span class="line">    [cell configUIWithObject:object withIndexPath:indexPath];</span><br><span class="line">&#125;</span><br><span class="line">cell.selectionStyle = UITableViewCellSelectionStyleNone;</span><br><span class="line">cell.delegate = self;	//代理</span><br><span class="line">return cell;</span><br></pre></td></tr></table></figure>
<p>这里注意下：每个cell都是有一个数据实例来显示，应该把具体的实现细节封装在内部，而不该在暴露在外面.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//在`.h`中声明方法</span><br><span class="line">@interface AMissionCell : UITableViewCell</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic) id &lt;AMissionCellDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">- (void)configUIWithObject:(AMission *)mission withIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//.m中的实现</span><br><span class="line">- (void)configUIWithObject:(AMission *)mission withIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    if (mission.isCompleted) &#123;</span><br><span class="line">        _checkImageView.image = [UIImage imageNamed:@&quot;cell_check_yes&quot;];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        _checkImageView.image = [UIImage imageNamed:@&quot;cell_check_no&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _label.text = mission.name;</span><br><span class="line">    </span><br><span class="line">    if (mission.isStar) &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">    _starImageView.image = [UIImage imageNamed:@&quot;cell_star_no&quot;];</span><br><span class="line">    </span><br><span class="line">    //赋值</span><br><span class="line">    _checkButton.tag = indexPath.row;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现cell的代理，大部分事件的处理在ViewControl中，你可以通过代理来把方法响应到ViewControl中</strong></p>
<p>代理定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@protocol AMissionCellDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)checkButtonTouched:(UIButton *)button;</span><br><span class="line">- (void)starButtonTouched:(UIButton *)button;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>设置代理变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (assign, nonatomic) id &lt;AMissionCellDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>
<p>声明代理<br><code>@interface CustomTableViewVC ()&lt;AMissionCellDelegate&gt;</code></p>
<p>设置代理<br><code>cell.delegate = self;</code></p>
<p>代理方法的实现</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> #pragma mark - AMissionCellDelegate</span><br><span class="line">- (void)checkButtonTouched:(UIButton *)button&#123;</span><br><span class="line"></span><br><span class="line">    if (button.tag &lt; _records.count) &#123;</span><br><span class="line">        AMission *misson = _records[button.tag];</span><br><span class="line">        NSLog(@&quot;改变了%@的状态&quot;,misson.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)starButtonTouched:(UIButton *)button&#123;</span><br><span class="line">    //自己实现，和check那边一样的道理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 实现效果：<br> <img src="https://raw.githubusercontent.com/codeTalkCC/ArcitlePhotos/master/%E9%9A%8F%E5%A4%84%E5%8F%AF%E8%A7%81%E7%9A%84UITableView/IMG_1940.jpg" alt="自定义cell"><br> 其他具体实现的细节，在文末有个链接，你可以下载demo细看</p>
<h4 id="三：带搜索框的UITableView"><a href="#三：带搜索框的UITableView" class="headerlink" title="三：带搜索框的UITableView"></a>三：带搜索框的UITableView</h4><p>1.添加UISearchBar对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> _searchBar = [[UISearchBar alloc]init];</span><br><span class="line">_searchBar.frame = CGRectMake(0, 66, [[UIScreen mainScreen]bounds].size.width, 66);</span><br><span class="line">_searchBar.delegate = self;</span><br><span class="line">_tableView.tableHeaderView = _searchBar;</span><br></pre></td></tr></table></figure>
<p>2.实现代理<br><code>UISearchBarDelegate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText&#123;</span><br><span class="line"></span><br><span class="line">    [self changeArrayWithText:searchText];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.实现搜索方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)changeArrayWithText:(NSString *)text&#123;</span><br><span class="line"></span><br><span class="line">    //获取初始数据</span><br><span class="line">    NSMutableArray *tempArray = [self querryData];</span><br><span class="line">    </span><br><span class="line">    //筛选</span><br><span class="line">    NSArray *resultArray = nil;</span><br><span class="line">    if (text.length) &#123;</span><br><span class="line">        NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;SELF contains[c] %@&quot;,text];</span><br><span class="line">        resultArray = [tempArray filteredArrayUsingPredicate:predicate];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        resultArray = tempArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //赋值与重新加载数据</span><br><span class="line">    _records = [[NSMutableArray alloc]initWithArray:resultArray];</span><br><span class="line">    [_tableView reloadData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UISearchBar</code>还可以以有很多定制化，大家自己试试，我这里不展开了。这里注意我的UISearchBar是赋值给tableView的headerView，不是添加上去的.<code>_tableView.tableHeaderView = _searchBar;</code><br>搜索框比较简单，关键在于NSPredicate的用法，重新筛选数据这步骤</p>
<p><a href="http://www.jianshu.com/p/88be28860cde" target="_blank" rel="external">NSPredicate的用法</a></p>
<h4 id="四-UItableView的内存管理和重用机制"><a href="#四-UItableView的内存管理和重用机制" class="headerlink" title="四:UItableView的内存管理和重用机制"></a>四:UItableView的内存管理和重用机制</h4><p>在UITableViewDataSource的代理方法中，返回cell那里,table有一个方法：<code>dequeueReusableCellWithIdentifier:</code>，这就是tableView的重用机制，苹果帮助我们管理cell的内存（滑动的时候进栈出栈），一般情况下我们不需要关系这个，但是有些时候，在特别是你一个tableView中有cell的类型、布局有时候会不一样，就很容易出错。所以了解下tableView的重用机制是很有必要的。</p>
<p>上面<code>第一节的tableView的基本使用</code>里，我创建了0-99的100字符的显示，以这个为例，我们先把它cell的内存打印出来看看<code>NSLog(@&quot;%@:%@&quot;,string,cell);</code></p>
<p>我的操作：先往上滑动5格，再往上滑动10格，往下滑动7格</p>
<p>内存打印情况：<img src="https://raw.githubusercontent.com/codeTalkCC/ArcitlePhotos/master/%E9%9A%8F%E5%A4%84%E5%8F%AF%E8%A7%81%E7%9A%84UITableView/cache.png" alt="内存情况"></p>
<p>我把相同的内存地址用颜色标注好了，一共有17个不同的cell内存，以后都是重用这些cell，</p>
<p>cell的重用机制规则如下，按照这个规则就是这样的内存打印情况（用自己脑瓜按照这个规则走一遍，刚好是这样的内存打印情况）<br>cell重用规则</p>
<p>今天我们来分析一下UITableViewCell的重用机制.<br>首先,我们要明白我们为什么需要使用这种机制,其次,这种机制的原理是什么.<br>我们先举个例子来说明.一个UITableView中有许多需要显示的cell,但是我们不可能每个都会浏览到,那么如果我们把这些数据全部都加载进去,是不是造成了内存的负担呢.<br>我们所能显示的区域通常只有一个屏幕的大小,那么那些屏幕之外的信息是不需要一次性全都加载完的,只有当我们滑动屏幕需要浏览的时候,我们才需要它加载进来.因此,就有了我们要介绍的这部分内容,UITabelViewCell的重用机制.<br>重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell,我们只创建屏幕可显示的最大的cell个数+1,然后去循环重复使用这些cell,既节省空间,又达到我们需要显示的效果.<br>这种机制下系统默认有一个可变数组NSMutableArray<em>  visiableCells,用来保存当前显示的cell.一个可变字典NSMutableDictnery</em> reusableTableCells,用来保存可重复利用的cell.(之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell).<br>系统第一次执行- (UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath这个方法的时候, reusableTableCells为空,[tableView dequeueReusableCellWithIdentifier:identifier]的返回值为nil,我们需要通过[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]方式来创建.<br>当我们的数据过多,整个屏幕的cell显示不完全时,这个方法的执行情况是 :</p>
<p>(1) 先执行[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier: identifier]创建整个屏幕能显示的cell数+1的cell(当我们拖动UITableView的时候,第一个cell没有移出屏幕,最下面的cell就已经存在),并指定相同或者不同的标示符identifier.把创建出的屏幕能显示的cell全部都加入到visiableCells数组中(最后一个创建的先不加入数组)，reusableTableCells为空.</p>
<p>(2)当我们拖动屏幕时,顶端的cell移出屏幕并加入到reusableTableCells字典中,键为identifier ,并把之前已经创建的但是没有加入到visiableCells的cell加入到visiableCells数组中.</p>
<p>(3)当我们接着拖动的时候,因为reusableTableCells中已经有值，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用，执行[tableView dequeueReusableCellWithIdentifier: identifier]，返回一个标示符为identifier的cell。该cell移出reusableTableCells之后加入到visiableCells；顶端的cell移出visiableCells并加入到reusableTableCells.如果visiableCells数组中没有找到identifier类型的cell,则再次重新alloc一个.</p>
<p>讲述规则的文字我是从网上摘录下来的，不是我自己写的。摘自：／李xiao屁的忧伤（简书作者）<br><a href="：http://www.jianshu.com/p/b2bba60c0976">重用规则</a></p>
<h4 id="深度定制UItableView"><a href="#深度定制UItableView" class="headerlink" title="深度定制UItableView"></a>深度定制UItableView</h4><p>你看，有时候想要实现这样的效果：<br><img src="https://raw.githubusercontent.com/codeTalkCC/ArcitlePhotos/master/%E9%9A%8F%E5%A4%84%E5%8F%AF%E8%A7%81%E7%9A%84UITableView/IMG_1936.jpg" alt="邮箱">.你就必须实现cell的深度定制，<br><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-26-make-swipeable-table-view-cell-actions-without-going-nuts-scroll-views.md" target="_blank" rel="external">教程链接</a></p>
<p>想要实现这样的效果，其实还有个另外更简单的方法，用别人造好的轮子就行了<br><a href="https://github.com/CEWendel/SWTableViewCell" target="_blank" rel="external">无敌风火轮</a><br>你也找找其他效果的，github上很多的。</p>
<h5 id="一些tips"><a href="#一些tips" class="headerlink" title="一些tips"></a>一些tips</h5><ul>
<li><ul>
<li>(void)tableView:(UITableView <em>)tableView willDisplayCell:<br>(UITableViewCell </em>)cell forRowAtIndexPath:(NSIndexPath <em>)indexPath;这个方法的调用在 - (UITableViewCell </em>)tableView:(UITableView <em>)tableView cellForRowAtIndexPath:(NSIndexPath </em>)indexPath;之后</li>
</ul>
</li>
<li>想要满屏分割线的tableView</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if ([tableView respondsToSelector:@selector(setSeparatorInset:)])</span><br><span class="line">&#123;</span><br><span class="line">    [tableView setSeparatorInset:UIEdgeInsetsZero];</span><br><span class="line">&#125;</span><br><span class="line">if ([tableView respondsToSelector:@selector(setLayoutMargins:)])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    [tableView setLayoutMargins:UIEdgeInsetsZero];</span><br><span class="line">&#125;</span><br><span class="line">if ([cell respondsToSelector:@selector(setLayoutMargins:)])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    [cell setLayoutMargins:UIEdgeInsetsZero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>消除TableView的上面空白部分：self代表UIViewController对象<br>self.automaticallyAdjustsScrollViewInsets = NO;</li>
</ul>
<p>最后：<a href="https://github.com/codeTalkCC/Blog_CodeTalkCC_Code/tree/master" target="_blank" rel="external">demo链接</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/07/20/block与多线程编程/" class="prev">PREV</a><a href="/2016/06/08/Git命令整理/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">zjcai</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 网络编程 · codeTalk</title><meta name="description" content="网络编程 - zjcai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/codeTalkCC" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/selfAbout.html" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">网络编程</h1><div class="post-info">2016年7月22日</div><div class="post-content"><center><strong>前言</strong></center><br><strong><em><br><br>大家听说过烽火戏诸侯的故事没？<br><br><a id="more"></a><br><br><br>    烽火戏诸侯，指西周时周幽王，为褒姒（bāo sì）一笑，点燃了烽火台，戏弄了诸侯。<br>    褒姒看了果然哈哈大笑。幽王很高兴，因而又多次点燃烽火。后来诸侯们都不相信了，也<br>    就渐渐不来了。后来犬戎攻破镐京，杀死周幽王，后来周幽王的儿子周平王即位，开始了<br>    东周时期<br><br><br>这和现代通讯技术有什么关系？别急，慢慢看，会有关系的！<br><br>在古代，通讯技术不发达，人们信息的交流方式有限，通讯基本靠吼 - 通过声音。但也有聪明的人想出了可以快速传播信息的方法，比如“烽火台”，当“京都”受到进攻的时候，马上点燃烽火台，那么几里外的相邻烽火台看到之后马上也点燃自己的烽火台(在镐京附近的骊山（在今陕西临潼东南）一带修筑了20多座烽火台，每隔几里地就是一座），以此通知附近的诸侯赶来救援。这种通讯方式就是点火的时候慢一点，对于2座相邻的烽火台，如果火升起来来了，那么看到火的时间在几微秒内就能看到。因为火是能看见的，就是通过光传播，光在空气的传播速度是3 </em> 10^8 m/s。贼快！<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-“同学们，为什么打雷的时候先看见闪电再听见声音？”</span><br><span class="line"></span><br><span class="line">-“因为眼睛在前面，耳朵在后面！”</span><br><span class="line"></span><br><span class="line">-“老师，别啊，我回答错了就错了，我错了，错了还不行嘛！你快把板砖放下！”</span><br></pre></td></tr></table></figure><br><br>为什么打雷的时候先看见闪电在听见声音？<br><br>正确答案：</strong>因为光的的传播速度比声音的传播速度快的多！<strong>

</strong>光是一种电磁波!<strong>

</strong>光是一种电磁波!<strong>

</strong>光是一种电磁波!<strong><br><br>重要的事情说3遍，而电磁波是现代通讯技术的中信息传播的主要载体，生活中的WiFi，蓝牙也是电磁波，小区开门那个刷一下开门那个其实是RF，也有NFC，这也是电磁波。大家大学刷过饭卡没？为什么放上去能扣款，你的钱还真少了。其实饭卡用的是RFID，也是一种电磁波。公交卡大多数用也是NFC，它也是种电磁波。目前的技术下，关于电磁波的通讯手段也就这些，另外跟大家说下LiFi技术（处于研究阶段），就是利用可见光通讯的技术（自己百度）。我只是想到一个非常搞笑的场景：我给你发了道光，快看，就是天上那道彩虹！，对方接受的时候可以是一段话或者一篇文章。”<br><br>这就是题目的来源：看！我给你发了一道光，那道光代表爱你！（哈哈，几年或者十几年后真的可能实现哦~）<br><br>其实这没什么惊奇的，WiFi早就这样了，当你微信发个朋友圈的时候，聊天的时候，那些信息其实是通过你家的路由器，或者附近的基站以wifi（电磁波）为载体，发到腾讯的服务器上<br>。不过WiFi你看不见摸不到。Lifi（可见光，也是种电磁波）看的见，但是也摸不着。为什么wifi看不见？因为人类的眼睛进化成这样子 - 人眼可以接收到的电磁波，波长大约在380至780nm之间。什么叫波长？自己百度，这里我就展开到这里，至于为什么人类的眼睛为什么这样以及电磁波是什么？大家自己研究下吧，我限于篇幅就不具体展开了。文末附录里可能会提到。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">电磁波，又称电磁辐射，是由同相振荡且互相垂直的电场与磁场在空间中以波的形式传递</span><br><span class="line">能量和动量，其传播方向垂直于电场与磁场构成的平面</span><br><span class="line">电磁波的传播速度是光速，以光的速度绕地球一周只要0.134秒。贼快！</span><br></pre></td></tr></table></figure><br><br>大家平时聊天的时候有时候可等待了好几秒才收到消息，因为虽然我们的信息在空气中传播的很快，但是你手机里的信息手机要处理，传到路由器上路由器要处理，传到基站上基站要处理，所以有时候是比较慢的。具体怎么处理？这就是我今天要讲的主要内容，今天我整理了3个方面的知识，没有计算机基础的人只看前言和第一节，附录就够了，有计算机基础的可以看后面的章节，欢迎后台留言讨论！<br><br>* </strong>一:现代通讯技术<strong><br>* </strong>二:TCP/IP协议族<strong><br>* </strong>三:iOS中的网络编程<strong><br>* </strong>附录<strong><br><br><br><center></center></strong>一:现代通讯技术**

<hr>
<p>电磁波首先由詹姆斯·麦克斯韦于1865年预测出来，而后由德国物理学家海因里希·赫兹于1887年至1888年间在实验中证实存在。</p>
<p><strong>互联网的历史</strong></p>
<blockquote>
<p>1986年，美国国家科学基金会创建了大学之间互联的骨干网络NSFNET，这是互联网历史上重要的一步。在1994年，NSFNET转为商业运营。1995年随着网络开放予商业，互联网中成功接入的比较重要的其他网络包括Usenet、Bitnet和多种商用X.25网络。<br>1990年代，整个网络向公众开放。1991年8月，蒂姆·伯纳斯-李在瑞士创立HTML、HTTP和欧洲粒子物理研究所的最初几个网页之后两年，他开始宣扬其万维网项目。在1993年，Mosaic网页浏览器版本1.0被发布了，在1994年晚期，公共利益在前学术和技术的互联网上稳步增长。1996年，“Internet”（互联网）一词被广泛的流传，不过是指几乎整个的万维网。</p>
<p>其间，经过一个十年，互联网成功地容纳了原有的计算机网络中的大多数（尽管像FidoNet的一些网络仍然保持独立）。这一快速发展要归功于互联网没有中央控制，以及互联网协议非私有的特质，前者造成了互联网有机的生长，而后者则鼓励了厂家之间的兼容，并防止了某一个公司在互联网上称霸。<br>互联网的成功，可从“Internet”这个术语的大、小写分化窥知一二。最初，互联网一词代表那些使用IP协议架设而成的网络，而今天，它已引申泛指各种类型的网络，不再局限于IP网络。于是以小写的互联网（internet，开头的“i”是小写字母）为任何分离的实体网络之集合，这些网络以一组通用的协议相连，形成逻辑上的单一网络。而大写的互联网（Internet，开头的“I”是大写字母）专指前身为ARPA网，后使用IP协议将各种实体网络链接成此单一逻辑网络。大写的互联网是小写互联网的其中一种形式，反过来却不然。[4]2002年起，有学者开始提议将“internet”一词用小写表示，理由是互联网已经成为人类生活的一部分，失去了专有的意义[5]；2016年，美联社认为“互联网”已和“电话”一样成为一件一般的事物，不具有专属商标的意义，于是开始在其格式手册中规定“internet”和“web”一词全部小写，纽约时报也随后跟进，[6][7]但同时亦有媒体提出不同意见[8]。</p>
</blockquote>
<p><strong>互联网的相关协议</strong></p>
<blockquote>
<p>最底层的是IP协议（英语：Internet Protocol，即互联网协议），是用于报文交换网络的一种面向数据的协议，这一协议定义了数据包在网际传送时的格式。目前使用最多的是IPv4版本，这一版本中用32位定义IP地址，尽管地址总数达到43亿，但是仍然不能满足现今全球网络飞速发展的需求，因此IPv6版本应运而生。在IPv6版本中，IP地址共有128位，“几乎可以为地球上每一粒沙子分配一个IPv6地址”。IPv6目前并没有普及，许多互联网服务提供商并不支持IPv6协议的连接。但是，可以预见，将来在IPv6的帮助下，任何家用电器都有可能连入互联网。<br>上一层是UDP协议和TCP协议，它们用于控制数据流的传输。UDP是一种不可靠的数据流传输协议，仅为网络层和应用层之间提供简单的接口。而TCP协议则具有高的可靠性，通过为数据报加入额外信息，并提供重发机制，它能够保证数据不丢包、没有冗余包以及保证数据包的顺序。对于一些需要高可靠性的应用，可以选择TCP协议；而相反，对于性能优先考虑的应用如流媒体等，则可以选择UDP协议。<br>最顶层的是一些应用层协议，这些协议定义了一些用于通用应用的数据报结构，其中包括：</p>
</blockquote>
<p>&gt;</p>
<ul>
<li>DNS：域名服务；</li>
<li>FTP：服务使用的是文件传输协议；</li>
<li>HTTP：所有的Web页面服务都是使用的超级文本传输协议；</li>
<li>POP3：邮局协议；</li>
<li>SMTP：简单邮件传输协议；</li>
<li>Telnet：远程登陆等</li>
</ul>
<p>另外我提一点，在智能家居，移动设备接入领域，MQTT也是非常流行的！</p>
<p><code>协议</code>：简单的理解就是一种约定，发送端和接收端共同约定好的！这样你的信息才能以各种形式传播，在空气中以电磁波的形式，在光纤中以光的形式，在数字电路中以电信号的方式，怎么转换？怎么传输？这些都是协议中商量好的，所以对方接受到这些信息后也能正确的解释成“正确的信息”</p>
<p><center><strong>二：TCP/IP协议族</strong></center></p>
<hr>
<p><img src="http://upload-images.jianshu.io/upload_images/1156719-5ab11b14ed460183.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="TCP/IP协议族"></p>
<blockquote>
<p>TCP/IP参考模型是一个抽象的分层模型，这个模型中，所有的TCP/IP系列网络协议都被归类到4个抽象的”层”中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。 完成一些特定的任务需要众多的协议协同工作，这些协议分布在参考模型的不同层中的，因此有时称它们为一个协议栈。 TCP/IP参考模型为TCP/IP协议栈订身制作。其中IP协议只关心如何使得数据能够跨越本地网络边界的问题，而不关心如何利用传输媒体，数据如何传输。整个TCP/IP协议栈则负责解决数据如何通过许许多多个点对点通路（一个点对点通路，也称为一”跳”, 1 hop）顺利传输，由此不同的网络成员能够在许多”跳”的基础上创建相互的数据通路。 如想分析更普遍的网络通信问题，ISO的OSI模型也能起更好的帮助作用。 因特网协议族是一组实现支持因特网和大多数商业网络运行的协议栈的网络传输协议。它有时也被称为TCP/IP协议组，这个名称来源于其中两个最重要的协议：传输控制协议（TCP）和因特网协议（IP），它们也是最先定义的两个协议。 同许多其他协议一样网络传输协议也可以看作一个多层组合，每层解决数据传输中的一组问题并且向使用这些低层服务的高层提供定义好的服务。高层逻辑上与用户更为接近，所处理数据更为抽象，它们依赖于低层将数据转换成最终能够进行实体控制的形式。 网络传输协议能够大致匹配到一些厂商喜欢使用的固定7层的OSI模型。然而这些层并非都能够很好地与基于ip的网络对应（根据应用的设计和支持网络的不同它们确实是涉及到不同的层）并且一些人认为试图将因特网协议组对应到OSI会带来混淆而不是有所帮助。</p>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>TCP/IP协议族按照层次由上到下，层层包装。最上面的就是应用层了，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次（不要告诉我你没用过udp玩星际）。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据（后面会讲到）以确定传输的目标。第四层是叫数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行<strong><em>CRC</em></strong>编码，为最后的数据传输做准备。再往下则是硬件层次了，负责网络的传输，这个层次的定义包括网线的制式，网卡的定义等等（这些我们就不用关心了，我们也不做网卡），所以有些书并不把这个层次放在tcp/ip协议族里面，因为它几乎和tcp/ip协议的编写者没有任何的关系。发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构非常有栈的味道，所以某些文章也把tcp/ip协议族称为tcp/ip协议栈。</p>
</blockquote>
<p>对于TCP/IP协议族，要细讲的话一本书也讲不完，我这里提一下就好，因为具体的话我也不懂。</p>
<p><center><strong>三:iOS中的网络编程</strong></center></p>
<hr>
<p>有原生的代码和引入第三方库AFNetworking，我讲下引入AFNetworking的代码，原生的用的比较少</p>
<p>1.HTTP</p>
<ul>
<li>get请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	//现实中很少用到，这是在AFNetWorking中的接口，调用下就好</span><br><span class="line">	- (AFHTTPRequestOperation *)GET:(NSString *)URLString</span><br><span class="line">                     parameters:(id)parameters</span><br><span class="line">                        success:(void (^)(AFHTTPRequestOperation *operation, id responseObject))success</span><br><span class="line">                        failure:(void (^)(AFHTTPRequestOperation *operation, NSError *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    AFHTTPRequestOperation *operation = [self HTTPRequestOperationWithHTTPMethod:@&quot;GET&quot; URLString:URLString parameters:parameters success:success failure:failure];</span><br><span class="line"></span><br><span class="line">    [self.operationQueue addOperation:operation];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>post请求:地址被我改了，避免信息泄露，大家见谅</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">NSString *httpString = [NSString stringWithFormat:@&quot;http://123.123.240.1:8080/test/ios/login?username=%@&amp;password=%@&quot;,userName,password];</span><br><span class="line">    // 初始化Manager</span><br><span class="line">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">    </span><br><span class="line">    // 不加上这句话，会报“Request failed: unacceptable content-type: text/plain”错误，因为我们要获取text/plain类型数据</span><br><span class="line">    manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    </span><br><span class="line">    // post请求</span><br><span class="line">    [manager POST:httpString parameters:nil constructingBodyWithBlock:^(id  _Nonnull formData) &#123;</span><br><span class="line">        // 拼接data到请求体，这个block的参数是遵守AFMultipartFormData协议的。</span><br><span class="line">        </span><br><span class="line">    &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line">        // 这里可以获取到目前的数据请求的进度</span><br><span class="line">        </span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        </span><br><span class="line">        // 请求成功，解析数据</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        id object = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingAllowFragments error:&amp;error];</span><br><span class="line">        if(error)&#123;</span><br><span class="line">            [SVProgressHUD showErrorWithStatus:@&quot;JSON数据解析出错&quot;];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if ([object isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">                BOOL sucess = [object[@&quot;success&quot;]boolValue];</span><br><span class="line">                if (sucess) &#123;</span><br><span class="line">                    [SVProgressHUD dismiss];</span><br><span class="line">                    [self pushToMainVC];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    [SVProgressHUD showErrorWithStatus:@&quot;用户名或密码错误&quot;];</span><br><span class="line">                    [_passwordView.layer addAnimation:[self errorAnimation] forKey:@&quot;shakeAnimation&quot;];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [SVProgressHUD showInfoWithStatus:@&quot;登录失败&quot;];</span><br><span class="line">            // 请求失败</span><br><span class="line">            NSLog(@&quot;请求失败:%@&quot;, [error localizedDescription]);</span><br><span class="line">            NSDictionary *userInfoDic = [error userInfo];</span><br><span class="line">            NSLog(@&quot;%@&quot;,userInfoDic);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>2.TCP<br>参见4.socket</p>
<p>3.UDP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  监听发送特定端口下的广播</span><br><span class="line"> *  监听端口：1992</span><br><span class="line"> *  发送端口：1995</span><br><span class="line"> */</span><br><span class="line">- (void)creatUDPSocket&#123;</span><br><span class="line">    _asyncUdpSocket = [[AsyncUdpSocket alloc]initIPv4];</span><br><span class="line">    _asyncUdpSocket.delegate = self;</span><br><span class="line">    [_asyncUdpSocket receiveWithTimeout:-1 tag:0];</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    </span><br><span class="line">    [_asyncUdpSocket enableBroadcast:YES error:&amp;error];</span><br><span class="line">    BOOL isBinded = [_asyncUdpSocket bindToPort:UDP_LOCAL_PORT error:&amp;error];</span><br><span class="line">    if (isBinded) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;绑定端口失败:%@&quot;,error);</span><br><span class="line">        [_asyncUdpSocket close];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //倒计时</span><br><span class="line">    _times = 0;</span><br><span class="line">    _sendTimmer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(cuntDown) userInfo:nil repeats:YES];</span><br><span class="line">    [_sendTimmer fire];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  发送UDP广播数据，唤醒空调,新逻辑：工装主动会发，不必唤醒</span><br><span class="line"> */</span><br><span class="line">- (void)sendData&#123;</span><br><span class="line">    char szData[2] = &#123;0&#125;;</span><br><span class="line">    szData[0] = 0xBE;</span><br><span class="line">    szData[1] = 0x01;</span><br><span class="line">    NSData *scanData = [NSData dataWithBytes:szData length:2];</span><br><span class="line">    [_asyncUdpSocket sendData:scanData toHost:UDP_HOST port:UDP_SEND_PORT withTimeout:-1 tag:0];</span><br><span class="line">    _times ++;</span><br><span class="line">    [_indicatorLabel setText:[NSString stringWithFormat:_TEXT(@&quot;正在连接...%ld&quot;),(long)(k_config_time_out-_times)]];</span><br><span class="line">    if (_times &gt; k_config_time_out) &#123;</span><br><span class="line">        [self configFail];</span><br><span class="line">        [_sendTimmer invalidate];</span><br><span class="line">        _sendTimmer = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cuntDown&#123;</span><br><span class="line">    _times ++;</span><br><span class="line">    [_indicatorLabel setText:[NSString stringWithFormat:_TEXT(@&quot;正在连接...%ld&quot;),(long)(k_config_time_out-_times)]];</span><br><span class="line">    if (_times &gt; k_config_time_out) &#123;</span><br><span class="line">        [self configFail];</span><br><span class="line">        [_sendTimmer invalidate];</span><br><span class="line">        _sendTimmer = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - AsyncUdpSocketDelegate</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  UDP接收到消息的回调</span><br><span class="line"> *</span><br><span class="line"> *  @param sock UDP对象</span><br><span class="line"> *  @param data 接收到的数据</span><br><span class="line"> *  @param tag  标签</span><br><span class="line"> *  @param host 链接地址</span><br><span class="line"> *  @param port 端口号</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回值</span><br><span class="line"> */</span><br><span class="line">- (BOOL)onUdpSocket:(AsyncUdpSocket *)sock didReceiveData:(NSData *)data withTag:(long)tag fromHost:(NSString *)host port:(UInt16)port&#123;</span><br><span class="line">	//这里根据数据可以做相应的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.Socket 一个全局socket，.m文件中的实现</p>
<p>因为我全部贴上的话超过微信字数限制了，我就贴一部分代码，有兴趣的后台留言联系，我把文件发你</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (LGSocketClient *)sharedSocketServe &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        if(socketServe == nil) &#123;</span><br><span class="line">            socketServe = [[[self class] alloc] init];</span><br><span class="line">            socketServe.socket = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return socketServe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+(id)allocWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    @synchronized(self)</span><br><span class="line">    &#123;</span><br><span class="line">        if (socketServe == nil)</span><br><span class="line">        &#123;</span><br><span class="line">            socketServe = [super allocWithZone:zone];</span><br><span class="line">            socketServe.socket = nil;</span><br><span class="line">            return socketServe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSInteger)startConnectSocket</span><br><span class="line">&#123;</span><br><span class="line">    NSInteger intergerReturn = 1;</span><br><span class="line">    if(self.socket)&#123;</span><br><span class="line">        [self.socket disconnect];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        self.socket = [[AsyncSocket alloc] initWithDelegate:self];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//    self.socket = [[AsyncSocket alloc] initWithDelegate:self];</span><br><span class="line">//    [self.socket setRunLoopModes:[NSArray arrayWithObject:NSRunLoopCommonModes]];</span><br><span class="line">    [self.socket setRunLoopModes:[NSArray arrayWithObject:NSRunLoopCommonModes]];</span><br><span class="line">    intergerReturn = [self SocketOpen:self.host port:TCP_PORT];</span><br><span class="line">    return intergerReturn;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)SocketOpen:(NSString*)addr port:(NSInteger)port</span><br><span class="line">&#123;</span><br><span class="line">    NSInteger intergerReturn = 1;</span><br><span class="line">    if (![self.socket isConnected])</span><br><span class="line">    &#123;</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        if(!addr)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        [self.socket connectToHost:addr onPort:port withTimeout:TIME_OUT error:&amp;error];</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            intergerReturn = 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            intergerReturn = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return intergerReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//断开连接及那些代理方法就不贴了</span><br></pre></td></tr></table></figure>
<p><center><strong>附录</strong></center></p>
<hr>
<p>主要是本文涉及到的一些名词解释：</p>
<ul>
<li><p>电磁波：</p>
<p>  电磁波，又称电磁辐射，是由同相振荡且互相垂直的电场与磁场在空间中以波的形式传递能量和动量，其传播方向垂直于电场与磁场构成的平面。电磁辐射的载体为光子，不需要依靠介质传播，在真空中的传播速度为光速。电磁辐射可按照频率分类，从低频率到高频率，主要包括无线电波、微波、红外线、可见光、紫外线、X射线和伽马射线。人眼可接收到的电磁辐射，波长大约在380至780nm之间，称为可见光。只要是本身温度大于绝对零度的物体，都可以发射电磁辐射，而世界上并不存在温度等于或低于绝对零度的物体。因此，人们周边所有的物体时刻都在进行电磁辐射。尽管如此，只有处于可见光频域以内的电磁波，才可以被人们肉眼看到。</p>
</li>
<li><p>TCP/IP协议族：</p>
<p>  互联网协议族（英语：Internet Protocol Suite，缩写为IPS）[1]，是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP[2]。因为这个协议家族的两个核心协议，包括TCP（传输控制协议）和IP（网际协议），为这个家族中最早通过的标准。</p>
</li>
</ul>
<ul>
<li><p>CRC:</p>
<p>  循环冗余校验（英语：Cyclic redundancy check，通称“CRC”）是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函數，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。一般来说，循环冗余校验的值都是32位的整数。由于本函数易于用二进制的电脑硬件使用、容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，因此获得广泛应用。</p>
</li>
<li><p>scoket</p>
<p>  柏克莱套接字（英语：Berkeley sockets） ，又称为BSD 套接字(BSD sockets)是一种应用程序接口（API），用于网际插座（Internet socket）与Unix域套接字，包括了一个用C语言写成的应用程序开发库，主要用于实现进程间通讯，在计算机网络通讯方面被广泛使用。</p>
<p>  Berkeley套接字（也作BSD套接字应用程序接口）刚开始是4.2BSD Unix操作系统（于1983发布）的一套应用程序接口。然而，由于AT&amp;T的专利保护着UNIX，所以只有在1989年伯克利大学才能自由地发布自己的操作系统和网络库。</p>
<p>  Berkeley套接字应用程序接口形成了事实上的网络套接字的标准精髓。 大多数其他的编程语言使用与这套用C语言写成的应用程序接口[1] 类似的接口。 这套应用程序接口也被用于Unix域套接字（Unix domain sockets），后者可以在单机上为进程间通讯（IPC）的接口。</p>
<p>  这种基于流的传输层接口（TLI）为套接字应用程序接口提供了一种选择。 不过，最近提供TLI应用程序接口的的系统同时也提供Berkeley套接字应用程序接口</p>
</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2017/03/25/极光推送集成小计/" class="prev">PREV</a><a href="/2016/07/20/block与多线程编程/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">zjcai</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>